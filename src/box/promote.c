/*
 * Copyright 2010-2018, Tarantool AUTHORS, please see AUTHORS file.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 *    copyright notice, this list of conditions and the
 *    following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * <COPYRIGHT HOLDER> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "box.h"
#include "replication.h"
#include "promote.h"
#include "error.h"
#include "msgpuck.h"
#include "xrow.h"
#include "space.h"
#include "schema.h"
#include "schema_def.h"
#include "txn.h"
#include "tuple.h"
#include "iproto_constants.h"
#include "opt_def.h"
#include "info.h"
#include "fiber_channel.h"
#include "evio.h"

enum promote_msg_type {
	/**
	 * 'Begin' is a first message in a promotion round sent by
	 * an initiator. Contains timeout, quorum.
	 */
	PROMOTE_MSG_BEGIN,
	/**
	 * Response to 'begin' message. Contains an instance role:
	 * master or replica.
	 */
	PROMOTE_MSG_STATUS,
	/**
	 * Message sent by a master before its demotion to sync
	 * its data with replicas.
	 */
	PROMOTE_MSG_SYNC,
	/** Response to 'sync' message. */
	PROMOTE_MSG_SUCCESS,
	/**
	 * Message to demote the sender. After demotion the
	 * instance still is a master until promote message is
	 * received from another instance.
	 */
	PROMOTE_MSG_DEMOTE,
	/**
	 * Message to promote the sender and to complete demotion
	 * of an old master.
	 */
	PROMOTE_MSG_PROMOTE,
	/**
	 * An error message can be sent by any promotion
	 * participant on timeout, unexpected message, outdated
	 * round ID etc.
	 */
	PROMOTE_MSG_ERROR,
	promote_msg_type_MAX,
};

static const char *promote_msg_type_strs[] = {
	"begin",
	"status",
	"sync",
	"success",
	"demote",
	"promote",
	"error",
};

/**
 * Promotion protocol covers two procedures: promotion and
 * demotion. Promotion elects a new master and precipitate an old
 * one. Demotion just makes a master be read-only so that it still
 * is a master in fact.
 */
enum round_type {
	ROUND_TYPE_PROMOTE,
	ROUND_TYPE_DEMOTE,
	/**
	 * Until 'begin' message is received the round type is
	 * undefined.
	 */
	round_type_MAX,
	ROUND_TYPE_UNDEFINED = round_type_MAX,
};

static const char *round_type_strs[] = {
	"promote",
	"demote",
	"undefined",
};

/**
 * Promotion message. The unit of communication between an
 * initiator, a master and watchers.
 */
struct promote_msg {
	/** Interface for fiber channel. */
	struct ipc_msg base;
	/**
	 * Round ID. Together with round UUID composes an unique
	 * round identifier. For details see promotion_state.
	 */
	int round_id;
	/** Promotion round UUID, generated by the initiator. */
	struct tt_uuid round_uuid;
	/** UUID of the message sender. */
	struct tt_uuid source_uuid;
	/**
	 * Timestamp of the message send time by the sender clock.
	 * Just debug attribute, that is persisted.
	 */
	double ts;
	/** Promotion message type. */
	enum promote_msg_type type;
	/**
	 * A Lamport timestampt to preserve a partial order of
	 * messages.
	 */
	int step;
	/**
	 * Depending on the message type, different attributes
	 * are available in the message.
	 */
	union {
		struct {
			/** Quorum of the upcoming round. */
			int quorum;
			/** Timeout of the upcoming round. */
			double timeout;
			/**
			 * Is the upcoming round about promotion
			 * or demotion.
			 */
			enum round_type round_type;
		} begin;
		struct {
			/** Sender role. */
			bool is_master;
			/**
			 * True if the sender is a currently
			 * active master being able to accept
			 * write requests. If false, then the
			 * master is demoted, but no new one is
			 * elected.
			 */
			bool is_promoted;
		} status;
		struct {
			/** Error code and message for diag. */
			int code;
			const char *message;
		} error;
	};
};

enum promote_role {
	/**
	 * Role of an instance becomes known only after one of the
	 * events:
	 * - its own 'status' message is committed;
	 * - its own 'begin' message is committed;
	 * - 'sync' is committed before any other messages.
	 *
	 * An instance can not be sure about is role before those
	 * events because of recovery. The tricky thing is that
	 * on recovery a promotion role should be restored by
	 * history of promotion rounds. And while the promotion
	 * status is under construction, it can not be used to
	 * set role.
	 *
	 * So the special role is introduced until one of events
	 * above. Technically, it is possible to set role before
	 * commit during normal operating after recovery, but it
	 * will not make any things easier or faster.
	 */
	PROMOTE_ROLE_UNDEFINED,
	/**
	 * An instance learns its initiator role when its 'begin'
	 * message is committed.
	 */
	PROMOTE_ROLE_INITIATOR,
	/**
	 * An instance learns its master role when its 'status'
	 * message is committed and contains is_master = true.
	 * Master is a being demoted instance.
	 */
	PROMOTE_ROLE_MASTER,
	/**
	 * An instance learns its watcher role when its 'status'
	 * message is committed and contains is_master = false.
	 * Watcher syncs with a master, participates in a quorum
	 * and rejects new promotion rounds when another exists.
	 */
	PROMOTE_ROLE_WATCHER
};

static const char *promote_role_strs[] = {
	"undefined",
	"initiator",
	"master",
	"watcher",
};

enum promote_phase {
	/**
	 * A promotion is inactive when a promotion history is
	 * empty.
	 */
	PROMOTE_PHASE_INACTIVE = 0,
	/**
	 * A promotion is in an error phase when an 'error'
	 * message of the currently active round is committed.
	 */
	PROMOTE_PHASE_ERROR,
	/**
	 * A promotion is in a success phase when it quited the
	 * latest round without errors.
	 */
	PROMOTE_PHASE_SUCCESS,
	/** A promotion is in progress in all other cases. */
	PROMOTE_PHASE_IN_PROGRESS,
};

static const char *promote_phase_strs[] = {
	"non-active",
	"error",
	"success",
	"in progress",
};

/**
 * A prototype of a function processing a message under a concrete
 * role with a concrete type.
 */
typedef void (*promote_msg_process_f)(const struct promote_msg *);

/**
 * Promotion state virtual table. It is defined for each promotion
 * role where the latter reacts specifically on each message. All
 * the functions are called for a currently active promotion
 * round.
 */
struct promote_state_vtab {
	/** Process a 'begin' message. */
	promote_msg_process_f begin;
	/** Process a 'status' message from a replica. */
	promote_msg_process_f new_replica;
	/** Process a 'status' message from a master. */
	promote_msg_process_f new_master;
	/** Process a 'sync' message. */
	promote_msg_process_f sync;
	/** Process a 'success' message. */
	promote_msg_process_f success;
	/** Process a 'demote' message. */
	promote_msg_process_f demote;
	/** Process a 'promote' message. */
	promote_msg_process_f promote;
	/** Process an 'error' message. */
	promote_msg_process_f error;
};

/**
 * The current promotion state. If the promotion is finished, then
 * the latest one is stored here as a cache for
 * box.ctl.promote_info().
 */
static struct promote_state {
	/**
	 * Each round has an unique identifier of two parts: ID
	 * and UUID. ID is used to order rounds by the time of
	 * their start. Each new round has an ID > than all the
	 * known previous ones. Timestamps can not be used since
	 * clocks are not perfectly sinced over network.
	 */
	int round_id;
	/**
	 * UUID is generated by a promotion initiator and allows
	 * to protect from a mess when promotions are started on
	 * different nodes at the same time with the same round
	 * IDs. UUIDs are different in them because of different
	 * initiators.
	 */
	struct tt_uuid round_uuid;
	/** Is this round about promotion or demotion. */
	enum round_type round_type;
	/**
	 * UUID of an active master if known, nil UUID otherwise.
	 */
	struct tt_uuid master_uuid;
	/** UUID of an initiator if known, nil UUID otherwise. */
	struct tt_uuid initiator_uuid;
	/** Diagnostics storing the current round error. */
	struct diag diag;
	/**
	 * Condition emited each time the promotion state is
	 * changed.
	 */
	struct fiber_cond on_change;
	/**
	 * Role of the current instance in the current promotion
	 * round.
	 */
	enum promote_role role;
	/**
	 * Description of the latest thing done during the current
	 * promotion round. It is not persisted anywhere and
	 * exists merely to improve user experience. It is shown
	 * in box.ctl.promote_info().
	 */
	char comment[DIAG_ERRMSG_MAX + 1];
	/**
	 * The current promotion round quorum. Becomes valid only
	 * when an initiator becomes known. Quorum is number of
	 * replicas that should approve the promotion and sync
	 * with the master before its demotion.
	 */
	int quorum;
	/**
	 * The current promotion round timeout. Once it is
	 * exceeded, the round is terminated with persisting that
	 * fact. Becomes valid only when an initiator becomes
	 * known.
	 */
	double timeout;
	/** Number of already collected syncs with the master. */
	int sync_count;
	/**
	 * Number of participants. It is used by a promotion
	 * initiator when it detected that a master is already
	 * demoted. In such a case the initiator still needs to
	 * collect a quorum of participants.
	 */
	int participant_count;
	/**
	 * Is set by an initiator when it detected that an old
	 * master is demoted. When quorum of participants is
	 * collected, the initiator uses this flag to promote
	 * itself.
	 *
	 * Also this flag is used by a master to detect that the
	 * round is failed before its demotion. In such a case it
	 * can safely get mastery back. Otherwise the master can
	 * not be sure that 'demote' message did not reached an
	 * initiator.
	 */
	bool is_master_demoted;
	/** Round start time and delay. */
	ev_tstamp round_start;
	ev_tstamp round_delay;
	/**
	 * Current round promotion phase or a finished round
	 * result.
	 */
	enum promote_phase phase;
	/**
	 * A Lamport clock to preserve a partial order of
	 * messages.
	 */
	int step;
	/** Virtual promotion methods depending on a role. */
	struct promote_state_vtab *vtab;
	/**
	 * Mastery flag. It is not the same as box_is_promoted()
	 * because an instance can be demoted but still be a
	 * master. It is possible that this flag is true, but
	 * box_is_promoted() is false.
	 */
	bool is_master;
	/** The promotion round worker fiber. */
	struct fiber *worker;
	/** Channel to push messages into worker fiber. */
	struct fiber_channel *channel;
} promote_state;

bool
promote_is_empty(void)
{
	return promote_state.phase == PROMOTE_PHASE_INACTIVE;
}

/**
 * Getters for different attributes and properties of the
 * promotion state.
 */

static inline bool
promote_is_active(void)
{
	return promote_state.phase == PROMOTE_PHASE_IN_PROGRESS;
}

static inline bool
promote_is_master_known(void)
{
	return !tt_uuid_is_equal(&promote_state.master_uuid, &uuid_nil);
}

static inline bool
promote_is_initiator_known(void)
{
	return !tt_uuid_is_equal(&promote_state.initiator_uuid, &uuid_nil);
}

static inline bool
promote_is_this_round_msg(const struct promote_msg *msg)
{
	return promote_is_active() &&
	       tt_uuid_is_equal(&msg->round_uuid, &promote_state.round_uuid);
}

/**
 * Comment a promotion event. The comment text is available to be
 * seen from box.ctl.promote_info(), and is logged.
 */
#define promote_comment(...) do { \
	snprintf(promote_state.comment, sizeof(promote_state.comment), \
		 __VA_ARGS__); \
	say_info(promote_state.comment); \
} while(0)

/**
 * Serialize the promotion message into a string.
 * @param msg Message to serialize.
 * @retval String with the serialized message.
 */
static inline const char *
promote_msg_str(const struct promote_msg *msg)
{
	int offset = 0;
	char *buf = tt_static_buf();
	int len = TT_STATIC_BUF_LEN;

	offset += snprintf(buf, len, "{id: %d, round: '", msg->round_id);
	tt_uuid_to_string(&msg->round_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', step: %d, source: '",
			   msg->step);
	tt_uuid_to_string(&msg->source_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', ts: %f, type: '%s'",
			   msg->ts, promote_msg_type_strs[msg->type]);
	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		offset += snprintf(buf + offset, len - offset, ", quorum: %d, "\
				   "timeout: %f, round_type: '%s'}",
				   msg->begin.quorum, msg->begin.timeout,
				   round_type_strs[msg->begin.round_type]);
		break;
	case PROMOTE_MSG_STATUS:
		offset += snprintf(buf + offset, len - offset, ", is_master: "\
				   "%d", (int) msg->status.is_master);
		if (msg->status.is_master) {
			offset += snprintf(buf + offset, len - offset,
					   ", is_promoted: %d}",
					   (int) msg->status.is_promoted);
		} else {
			offset += snprintf(buf + offset, len - offset, "}");
		}
		break;
	case PROMOTE_MSG_ERROR:
		offset += snprintf(buf + offset, len - offset, ", code: %d, "\
				   "message: '%s'}", msg->error.code,
				   msg->error.message);
		break;
	default:
		offset += snprintf(buf + offset, len - offset, "}");
		break;
	}
	return buf;
}

/**
 * Encode the promotion message into MessagePack tuple ready to
 * be inserted into _promotion space.
 * @param msg Promotion message to encode.
 *
 * @retval NULL Error.
 * @retval not NULL MessagePack encoded message.
 */
static const char *
promote_msg_encode(const struct promote_msg *msg)
{
	/*
	 * Do not waste time on precise size calculation. 1Kb is
	 * enough for any message.
	 */
	int size = 1024;
	char *data = region_alloc(&fiber()->gc, size);
	if (data == NULL) {
		diag_set(OutOfMemory, size, "region_alloc", "data");
		return NULL;
	}
	char *begin = data;
	data = mp_encode_array(data, 7);
	data = mp_encode_uint(data, msg->round_id);
	data = mp_encode_str(data, tt_uuid_str(&msg->round_uuid),
			     UUID_STR_LEN);
	data = mp_encode_uint(data, msg->step);
	data = mp_encode_str(data, tt_uuid_str(&msg->source_uuid),
			     UUID_STR_LEN);
	data = mp_encode_double(data, msg->ts);
	const char *type_str = promote_msg_type_strs[msg->type];
	data = mp_encode_str(data, type_str, strlen(type_str));
	switch(msg->type) {
	case PROMOTE_MSG_BEGIN:
		if (msg->begin.timeout != TIMEOUT_INFINITY)
			data = mp_encode_map(data, 3);
		else
			data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "quorum", strlen("quorum"));
		data = mp_encode_uint(data, msg->begin.quorum);
		type_str = round_type_strs[msg->begin.round_type];
		data = mp_encode_str(data, "round_type", strlen("round_type"));
		data = mp_encode_str(data, type_str, strlen(type_str));
		if (msg->begin.timeout != TIMEOUT_INFINITY) {
			data = mp_encode_str(data, "timeout",
					     strlen("timeout"));
			data = mp_encode_double(data, msg->begin.timeout);
		}
		break;
	case PROMOTE_MSG_STATUS:
		if (msg->status.is_master)
			data = mp_encode_map(data, 2);
		else
			data = mp_encode_map(data, 1);
		data = mp_encode_str(data, "is_master", strlen("is_master"));
		data = mp_encode_bool(data, msg->status.is_master);
		if (msg->status.is_master) {
			data = mp_encode_str(data, "is_promoted",
					     strlen("is_promoted"));
			data = mp_encode_bool(data, msg->status.is_promoted);
		}
		break;
	case PROMOTE_MSG_ERROR:
		data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "code", strlen("code"));
		data = mp_encode_uint(data, msg->error.code);
		data = mp_encode_str(data, "message", strlen("message"));
		data = mp_encode_str(data, msg->error.message,
				     strlen(msg->error.message));
		break;
	default:
		data = mp_encode_nil(data);
		break;
	};
	assert(data - begin <= size);
	return begin;
}

const struct opt_def promote_msg_begin_format[] = {
	OPT_DEF("quorum", OPT_UINT32, struct promote_msg, begin.quorum),
	OPT_DEF("timeout", OPT_FLOAT, struct promote_msg, begin.timeout),
	OPT_DEF_ENUM("round_type", round_type, struct promote_msg,
		     begin.round_type, NULL),
	OPT_END,
};

const struct opt_def promote_msg_status_format[] = {
	OPT_DEF("is_master", OPT_BOOL, struct promote_msg, status.is_master),
	OPT_DEF("is_promoted", OPT_BOOL, struct promote_msg, status.is_promoted),
	OPT_END,
};

const struct opt_def promote_msg_error_format[] = {
	OPT_DEF("code", OPT_UINT32, struct promote_msg, error.code),
	OPT_DEF("message", OPT_STRPTR, struct promote_msg, error.message),
	OPT_END,
};

void
promote_msg_delete(struct promote_msg *msg)
{
	free(msg);
}

struct promote_msg *
promote_msg_new_from_tuple(const char *data)
{
	uint32_t msg_sizeof = sizeof(struct promote_msg);
	uint32_t len, size = mp_decode_array(&data);
	assert(size == 7 || size == 6);
	struct region *region = &fiber()->gc;
	struct promote_msg base;
	base.round_id = (int) mp_decode_uint(&data);
	const char *str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &base.round_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_ROUND_UUID, "invalid UUID");
		return NULL;
	}
	if (! box_is_promotable()) {
		diag_set(ClientError, ER_PROMOTE, tt_uuid_str(&base.round_uuid),
			 "promotion is not allowed on this instance");
		return NULL;
	}
	base.step = (int) mp_decode_uint(&data);
	str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &base.source_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_SOURCE_UUID, "invalid UUID");
		return NULL;
	}
	if (mp_read_double(&data, &base.ts) != 0 || base.ts < 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TS, "wrong ts");
		return NULL;
	}
	str = mp_decode_str(&data, &len);
	base.type = STRN2ENUM(promote_msg_type, str, len);
	if (base.type == promote_msg_type_MAX) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TYPE, "wrong type");
		return NULL;
	}

	switch(base.type) {
	case PROMOTE_MSG_BEGIN:
		base.begin.quorum = -1;
		base.begin.timeout = TIMEOUT_INFINITY;
		base.begin.round_type = ROUND_TYPE_PROMOTE;
		if (opts_decode(&base, promote_msg_begin_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		if (base.begin.quorum <= replicaset.applier.total / 2 &&
		    base.begin.round_type == ROUND_TYPE_PROMOTE) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE, "quorum should be "\
				 "> 50%% of replicaset size");
			return NULL;
		}
		if (base.begin.round_type == round_type_MAX) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE,
				 "round_type is unknown");
			return NULL;
		}
		break;
	case PROMOTE_MSG_STATUS:
		base.status.is_master = false;
		base.status.is_promoted = false;
		if (opts_decode(&base, promote_msg_status_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		break;
	case PROMOTE_MSG_ERROR:
		base.error.code = -1;
		base.error.message = NULL;
		if (opts_decode(&base, promote_msg_error_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		if (base.error.code < 0 || base.error.message == NULL) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE, "error code and "\
				 "message should be specified");
			return NULL;
		}
		msg_sizeof += strlen(base.error.message) + 1;
		break;
	default:
		if (size == 7) {
			if (mp_typeof(*data) != MP_NIL) {
				diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
					 BOX_PROMOTION_FIELD_VALUE, "value "\
					 "expected to be nil");
				return NULL;
			}
			mp_decode_nil(&data);
		}
		break;
	};
	struct promote_msg *msg = (struct promote_msg *) malloc(msg_sizeof);
	if (msg == NULL) {
		diag_set(OutOfMemory, msg_sizeof, "malloc", "msg");
		return NULL;
	}
	*msg = base;
	msg->base.destroy = (void(*)(struct ipc_msg *)) promote_msg_delete;
	if (msg->type == PROMOTE_MSG_ERROR) {
		char *errmsg = (char *) (msg + 1);
		memcpy(errmsg, base.error.message, msg_sizeof - sizeof(*msg));
		msg->error.message = errmsg;
	}
	return msg;
}

/** True, if @a msg is created by the current instance. */
static inline bool
promote_msg_is_mine(const struct promote_msg *msg)
{
	return tt_uuid_is_equal(&msg->source_uuid, &INSTANCE_UUID);
}

/** Broadcast a message via writing into _promotion space. */
static inline int
promote_do_send(const struct promote_msg *msg)
{
	const char *data = promote_msg_encode(msg);
	if (data == NULL)
		return -1;
	return boxk(IPROTO_INSERT, BOX_PROMOTION_ID, "%p", data);
}

/**
 * Same as do_send, but do nothing on recovery. If a message was
 * sent on the previous work session, it would be recovered among
 * next rows. Otherwise the round will be terminated by timeout.
 */
static inline int
promote_send(const struct promote_msg *msg)
{
	if (! box_is_configured())
		return 0;
	return promote_do_send(msg);
}

/**
 * Create the promotion message in scope of the current round with
 * next step.
 * @param[out] msg Message to create.
 * @param type Type to set to @a msg.
 */
static inline void
promote_msg_create(struct promote_msg *msg, enum promote_msg_type type)
{
	msg->round_id = promote_state.round_id;
	msg->round_uuid = promote_state.round_uuid;
	msg->source_uuid = INSTANCE_UUID;
	msg->ts = fiber_time();
	msg->type = type;
	msg->step = ++promote_state.step;
}

/**
 * Make @a msg message be an initial message of a new round. An
 * initial message of a round should propagate round ID, reset
 * round UUID and has a first step to guarantee a correct order in
 * the _promotion space's primary index.
 * @param msg Message to make initial.
 */
static inline void
promote_msg_make_initial(struct promote_msg *msg)
{
	tt_uuid_create(&msg->round_uuid);
	msg->round_id++;
	msg->step = 1;
}

/**
 * Send a 'begin' promotion message. For this a new round is
 * initialized.
 */
static inline int
promote_send_begin(int quorum, double timeout, enum round_type round_type)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_BEGIN);
	msg.begin.quorum = quorum;
	msg.begin.timeout = timeout;
	msg.begin.round_type = round_type;
	promote_msg_make_initial(&msg);
	return promote_send(&msg);
}

/**
 * Send a promotion message. It is a finish of a promotion round.
 */
static inline int
promote_send_promote()
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_PROMOTE);
	return promote_send(&msg);
}

/**
 * Send a 'status' promotion message. It contains a role of this
 * instance. The message is sent as a response to 'begin' message.
 */
static inline int
promote_send_status(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_STATUS);
	msg.status.is_master = promote_state.is_master;
	if (promote_state.is_master)
		msg.status.is_promoted = box_is_promoted();
	return promote_send(&msg);
}

/**
 * Send a 'sync' promotion message. It is sent by this instance if
 * it is a master to be demoted. Sync brings this instance into
 * read-only mode, while watchers and the initiator respond to
 * this message with 'success'.
 */
static inline int
promote_send_sync(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SYNC);
	return promote_send(&msg);
}

/**
 * Send a 'success' promotion message. It is sent by a promotion
 * watcher and an initiator as a response to 'sync'.
 */
static inline int
promote_send_success(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SUCCESS);
	return promote_send(&msg);
}

/**
 * Send a 'demote' promotion message from a master which is either
 * demoted explicitly or as a part of another instance promotion.
 */
static inline int
promote_send_demote(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_DEMOTE);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message. It is sent by any instace
 * on different errors like timeout, multiple masters discovery,
 * local errors (OOM, WAL error etc). This message is sent in
 * scope of the current round and on commit terminates the
 * promotion round.
 */
static inline int
promote_send_error(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message out of scope of the current
 * round. For example, as a response to unexpected message from
 * another round while there is the active current round.
 */
static inline int
promote_send_out_of_bound_error(int round_id, const struct tt_uuid *round_uuid,
				int step)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	msg.round_id = round_id;
	msg.round_uuid = *round_uuid;
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	msg.step = step;
	return promote_send(&msg);
}

static inline int
promote_begin_and_wait(double timeout, int quorum, enum round_type round_type)
{
	if (! box_is_configured()) {
		diag_set(ClientError, ER_LOADING);
		return -1;
	}
	if (! box_is_promotable()) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 "promotion is not enabled");
		return -1;
	}
	if (promote_is_active()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	int id = promote_state.round_id;
	if (promote_send_begin(quorum, timeout, round_type) != 0)
		return -1;

	while (promote_state.round_id == id ||
	       promote_state.phase != PROMOTE_PHASE_SUCCESS) {
		fiber_cond_wait(&promote_state.on_change);
		if (promote_state.phase == PROMOTE_PHASE_ERROR) {
			assert(! diag_is_empty(&promote_state.diag));
			diag_move(&promote_state.diag, diag_get());
			return -1;
		}
	}
	return 0;
}

int
box_ctl_promote(double timeout, int quorum)
{
	if (quorum < 0)
		quorum = replicaset.applier.total;
	if (box_is_promoted()) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 "the instance is already promoted");
		return -1;
	}
	if (quorum <= replicaset.applier.total / 2) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 tt_sprintf("too small quorum, expected > %d, "\
				    "but got %d", replicaset.applier.total / 2,
				    quorum));
		return -1;
	}
	return promote_begin_and_wait(timeout, quorum, ROUND_TYPE_PROMOTE);
}

int
box_ctl_demote(double timeout, int quorum)
{
	if (quorum < 0)
		quorum = replicaset.applier.total;
	if (! box_is_promoted()) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 "the instance is already demoted");
		return -1;
	}
	return promote_begin_and_wait(timeout, quorum, ROUND_TYPE_DEMOTE);
}

int
box_ctl_initial_promote(void)
{
	assert(box_is_promotable());
	assert(! box_is_promoted());
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_PROMOTE);
	promote_msg_make_initial(&msg);
	if (promote_do_send(&msg) != 0)
		return -1;
	while (! promote_state.is_master) {
		fiber_cond_wait(&promote_state.on_change);
		if (promote_state.phase == PROMOTE_PHASE_ERROR) {
			diag_move(diag_get(), &promote_state.diag);
			return -1;
		}
	}
	return 0;
}

/**
 * Delete the promotion round with the specified id.
 * @param id Round ID to delete by.
 * @param[out] next_id ID of a next round. If no more rounds, is
 *             set to @a id.
 * @param pk Primary index of the _promotion space.
 *
 * @retval 0 Success.
 * @retval -1 Error.
 */
static inline int
promote_clean_round(uint32_t id, uint32_t *next_id, struct index *pk)
{
	if (promote_is_active()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	char key[16];
	mp_encode_uint(key, id);
	if (index_count(pk, ITER_ALL, NULL, 0) == 0) {
		*next_id = id;
		return 0;
	}
	if (! box_is_configured()) {
		diag_set(ClientError, ER_LOADING);
		return -1;
	}
	struct request request;
	memset(&request, 0, sizeof(request));
	request.type = IPROTO_DELETE;
	request.space_id = BOX_PROMOTION_ID;
	struct iterator *it = index_create_iterator(pk, ITER_GE, key, 1);
	if (it == NULL)
		return -1;
	if (box_txn_begin() != 0) {
		iterator_delete(it);
		return -1;
	}
	struct tuple *t;
	int rc;
	struct key_def *pk_def = pk->def->key_def;
	while ((rc = iterator_next(it, &t)) == 0 && t != NULL) {
		tuple_field_u32(t, BOX_PROMOTION_FIELD_ID, next_id);
		if (*next_id != id)
			break;
		const char *del = tuple_extract_key(t, pk_def, NULL);
		if (del == NULL)
			goto rollback;
		if (boxk(IPROTO_DELETE, BOX_PROMOTION_ID, "%p", del) != 0)
			goto rollback;
	}
	if (rc != 0 || box_txn_commit() != 0)
		goto rollback;
	iterator_delete(it);
	return 0;
rollback:
	box_txn_rollback();
	iterator_delete(it);
	return -1;
}

int
promote_reset_until(uint32_t until)
{
	uint32_t id, next_id = 0;
	struct index *pk = space_index(space_by_id(BOX_PROMOTION_ID), 0);
	do {
		id = next_id;
		if (promote_clean_round(id, &next_id, pk) != 0)
			return -1;
	} while (id != next_id && next_id < until);
	return 0;
}

int
box_ctl_promote_reset(void)
{
	if (promote_reset_until(UINT32_MAX) != 0)
		return -1;
	promote_state.phase = PROMOTE_PHASE_INACTIVE;
	promote_state.is_master = false;
	box_set_promote_status(false);
	return 0;
}

void
box_ctl_promote_info(struct info_handler *info)
{
	struct promote_state *s = &promote_state;
	info_begin(info);
	if (s->phase == PROMOTE_PHASE_INACTIVE) {
		info_end(info);
		return;
	}
	info_append_int(info, "round_id", s->round_id);
	info_append_str(info, "round_uuid", tt_uuid_str(&s->round_uuid));
	info_append_str(info, "round_type", round_type_strs[s->round_type]);
	info_append_int(info, "participant_count", s->participant_count);
	if (promote_is_initiator_known()) {
		info_append_str(info, "initiator_uuid",
				tt_uuid_str(&s->initiator_uuid));
		info_append_int(info, "quorum", s->quorum);
		info_append_double(info, "timeout", s->timeout);
	}
	info_append_str(info, "role", promote_role_strs[s->role]);
	info_append_str(info, "phase", promote_phase_strs[s->phase]);
	info_append_str(info, "comment", s->comment);
	if (promote_is_master_known()) {
		info_append_str(info, "master_uuid",
				tt_uuid_str(&s->master_uuid));
	}
	info_append_bool(info, "is_master", s->is_master);
	info_append_bool(info, "is_promoted", box_is_promoted());
	info_end(info);
}

void
promote_msg_push(struct promote_msg *msg)
{
	fiber_channel_put_msg_timeout(promote_state.channel, &msg->base,
				      TIMEOUT_INFINITY);
}

/** Set a new role, update virtual table, comment. */
static void
promote_state_set_role(enum promote_role role);

/** Placeholder to skip some messages when they do not matter. */
static void
promote_msg_skip(const struct promote_msg *msg)
{
	(void) msg;
}

/**
 * A function to assure the message can not reach a state of the
 * promotion.
 */
static void
promote_msg_unreachable(const struct promote_msg *msg)
{
	(void) msg;
	unreachable();
}

/** Undefined role. {{{ */

static void
promote_default_begin(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_BEGIN);
	promote_state.initiator_uuid = msg->source_uuid;
	promote_state.quorum = msg->begin.quorum;
	promote_state.timeout = msg->begin.timeout;
	promote_state.round_type = msg->begin.round_type;
	evio_timeout_init(loop(), &promote_state.round_start,
			  &promote_state.round_delay, promote_state.timeout);
	if (! promote_msg_is_mine(msg)) {
		promote_send_status();
	} else if (promote_state.round_type == ROUND_TYPE_DEMOTE) {
		promote_state_set_role(PROMOTE_ROLE_MASTER);
		promote_send_sync();
	} else {
		assert(promote_state.round_type == ROUND_TYPE_PROMOTE);
		promote_state_set_role(PROMOTE_ROLE_INITIATOR);
		if (promote_state.is_master) {
			/* Promotion was on and off. */
			assert(! box_is_promoted());
			promote_state.is_master_demoted = true;
			promote_state.vtab->new_master(msg);
		}
	}
}

static void
promote_default_new_replica(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_STATUS);
	assert(! msg->status.is_master);
	if (promote_msg_is_mine(msg))
		promote_state_set_role(PROMOTE_ROLE_WATCHER);
}

static void
promote_default_new_master(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
	assert(msg->type == PROMOTE_MSG_STATUS);
	assert(msg->status.is_master);
	if (! promote_msg_is_mine(msg))
		return;
	if (msg->status.is_promoted) {
		promote_state_set_role(PROMOTE_ROLE_MASTER);
		promote_send_sync();
	} else {
		promote_state_set_role(PROMOTE_ROLE_WATCHER);
	}
}

/*
 * It is possible that 'sync' is received before the instance's
 * own status and its role is undefined. For example, if 'begin'
 * is received from one applier and 'sync' from another and the
 * latter managed to commit earlier. This is the only reason why
 * the protocol shall withstand messages reordering.
 */
static void
promote_default_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
	assert(msg->type == PROMOTE_MSG_SYNC);
	assert(! promote_msg_is_mine(msg));
	(void) msg;
	promote_state_set_role(PROMOTE_ROLE_WATCHER);
	promote_send_success();
}

/**
 * A role can be still undefined, for example, on promotion during
 * bootstrap.
 */
static void
promote_default_promote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
	assert(msg->type == PROMOTE_MSG_PROMOTE);
	assert(promote_state.round_type == ROUND_TYPE_UNDEFINED);
	bool is_mine = promote_msg_is_mine(msg);
	box_set_promote_status(is_mine);
	promote_state.is_master = is_mine;
	if (is_mine) {
		promote_comment("the instance is promoted");
	} else {
		promote_comment("a remote instance '%s' is promoted",
				tt_uuid_str(&msg->source_uuid));
	}
	promote_state.phase = PROMOTE_PHASE_SUCCESS;
}

static void
promote_default_error(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_ERROR);
	promote_comment("the round failed due to the error: %s",
			msg->error.message);
	promote_state.phase = PROMOTE_PHASE_ERROR;
	box_error_raise(msg->error.code, "%s", msg->error.message);
	diag_move(diag_get(), &promote_state.diag);
}

static struct promote_state_vtab default_vtab = {
	/* .begin = */ promote_default_begin,
	/* .new_replica = */ promote_default_new_replica,
	/* .new_master = */ promote_default_new_master,
	/* .sync = */ promote_default_sync,
	/* .success = */ promote_msg_skip,
	/* .demote = */ promote_msg_unreachable,
	/* .promote = */ promote_default_promote,
	/* .error = */ promote_default_error,
};

/** Undefined role. }}} */

/** Initiator role. {{{ */

static void
promote_initiator_new_participant(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert((msg->type == PROMOTE_MSG_STATUS && !promote_msg_is_mine(msg)) ||
		msg->type == PROMOTE_MSG_BEGIN && promote_msg_is_mine(msg));
	(void) msg;
	/*
	 * If an old master is demoted already
	 * (by box.ctl.demote()) then it is needed neither collect
	 * syncs nor wait for new demote. Just wait quorum and do
	 * promote.
	 */
	if (promote_state.is_master_demoted &&
	    promote_state.participant_count >= promote_state.quorum)
		promote_send_promote();
}

static void
promote_initiator_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_SYNC);
	assert(! promote_msg_is_mine(msg));
	(void) msg;
	promote_send_success();
}

static void
promote_initiator_demote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_DEMOTE);
	assert(tt_uuid_is_equal(&msg->source_uuid, &promote_state.master_uuid));
	(void) msg;
	promote_send_promote();
}

static void
promote_initiator_promote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_PROMOTE);
	assert(promote_msg_is_mine(msg));
	(void) msg;
	promote_comment("the new master is promoted");
	promote_state.phase = PROMOTE_PHASE_SUCCESS;
	box_set_promote_status(true);
	promote_state.is_master = true;
	promote_reset_until(promote_state.round_id);
}

static struct promote_state_vtab initiator_vtab = {
	/* .begin = */ promote_msg_unreachable,
	/* .new_replica = */ promote_initiator_new_participant,
	/* .new_master = */ promote_initiator_new_participant,
	/* .sync = */ promote_initiator_sync,
	/* .success = */ promote_msg_skip,
	/* .demote = */ promote_initiator_demote,
	/* .promote = */ promote_initiator_promote,
	/* .error = */ promote_default_error,
};

/** Initiator role. }}} */

/** Master role. {{{ */

static void
promote_master_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_SYNC);
	promote_comment("master entered readonly mode to sync with slaves");
	box_set_promote_status(false);
	/* Synced with self. */
	promote_state.vtab->success(msg);
}

static void
promote_master_success(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_SUCCESS ||
	       msg->type == PROMOTE_MSG_SYNC);
	(void) msg;
	if (++promote_state.sync_count >= promote_state.quorum)
		promote_send_demote();
}

static void
promote_master_demote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_DEMOTE);
	assert(promote_msg_is_mine(msg));
	(void) msg;
	promote_comment("the master is demoted");
	if (promote_state.round_type == ROUND_TYPE_DEMOTE)
		promote_state.phase = PROMOTE_PHASE_SUCCESS;
}

static void
promote_master_promote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_PROMOTE);
	assert(! promote_msg_is_mine(msg));
	assert(promote_state.round_type == ROUND_TYPE_PROMOTE);
	promote_state.is_master = false;
	promote_state.phase = PROMOTE_PHASE_SUCCESS;
	promote_comment("a remote instance '%s' is promoted",
			tt_uuid_str(&msg->source_uuid));
}

static void
promote_master_error(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_ERROR);
	if (promote_state.phase == PROMOTE_PHASE_IN_PROGRESS &&
	    !promote_state.is_master_demoted && !box_is_promoted()) {
		promote_comment("the master is back in read-write mode due to "\
				"the error");
		box_set_promote_status(true);
	}
	promote_default_error(msg);
}

static struct promote_state_vtab master_vtab = {
	/* .begin = */ promote_msg_unreachable,
	/* .new_replica = */ promote_msg_skip,
	/* .new_master = */ promote_msg_unreachable,
	/* .sync = */ promote_master_sync,
	/* .success = */ promote_master_success,
	/* .demote = */ promote_master_demote,
	/* .promote = */ promote_master_promote,
	/* .error = */ promote_master_error,
};

/** Master role. }}} */

/** Watcher role. {{{ */

static void
promote_watcher_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_WATCHER);
	assert(msg->type == PROMOTE_MSG_SYNC);
	assert(! promote_msg_is_mine(msg));
	(void) msg;
	promote_send_success();
}

static void
promote_watcher_demote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_WATCHER);
	assert(msg->type == PROMOTE_MSG_DEMOTE);
	assert(! promote_msg_is_mine(msg));
	(void) msg;
	if (promote_state.round_type == ROUND_TYPE_DEMOTE) {
		promote_state.phase = PROMOTE_PHASE_SUCCESS;
		promote_comment("the watcher left the demotion round");
	}
}

static void
promote_watcher_promote(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_WATCHER);
	assert(msg->type == PROMOTE_MSG_PROMOTE);
	assert(! promote_msg_is_mine(msg));
	assert(promote_state.round_type == ROUND_TYPE_PROMOTE);
	(void) msg;
	if (promote_state.is_master) {
		/*
		 * Possible if the master was demoted by
		 * box.ctl.demote() and this round played as a
		 * watcher.
		 */
		promote_state.is_master = false;
		assert(! box_is_promoted());
	}
	promote_state.phase = PROMOTE_PHASE_SUCCESS;
	promote_comment("the watcher left the promotion round");
}

static struct promote_state_vtab watcher_vtab = {
	/* .begin = */ promote_default_begin,
	/* .new_replica = */ promote_msg_skip,
	/* .new_master = */ promote_msg_skip,
	/* .sync = */ promote_watcher_sync,
	/* .success = */ promote_msg_skip,
	/* .demote = */ promote_watcher_demote,
	/* .promote = */ promote_watcher_promote,
	/* .error = */ promote_default_error,
};

/** Watcher role. }}} */

static void
promote_state_set_role(enum promote_role role)
{
	promote_state.role = role;
	switch(role) {
	case PROMOTE_ROLE_UNDEFINED:
		promote_state.vtab = &default_vtab;
		return;
	case PROMOTE_ROLE_INITIATOR:
		promote_state.vtab = &initiator_vtab;
		break;
	case PROMOTE_ROLE_MASTER:
		promote_state.vtab = &master_vtab;
		break;
	case PROMOTE_ROLE_WATCHER:
		promote_state.vtab = &watcher_vtab;
		break;
	}
	promote_comment("promotion is started, my role is %s",
			 promote_role_strs[role]);
}

/**
 * Check a new message belongs to the current round, or start a
 * new one. Forward it to the appropriate virtual method. Filter
 * out some commonplace errors.
 */
static void
promote_msg_process(const struct promote_msg *msg)
{
	if (box_is_configured()) {
		say_info("promotion message has %s: %s",
			 promote_msg_is_mine(msg) ? "committed" : "received",
			 promote_msg_str(msg));
	} else {
		say_info("promotion message has recovered: %s",
			 promote_msg_str(msg));
	}
	if (! promote_is_active()) {
		if (msg->round_id <= promote_state.round_id) {
			say_info("Ignored outdated round id %u, expected > %u",
				 msg->round_id, promote_state.round_id);
			return;
		}
		promote_state.step = msg->step;
		promote_state.round_id = msg->round_id;
		promote_state.round_uuid = msg->round_uuid;
		promote_state.master_uuid = uuid_nil;
		diag_clear(&promote_state.diag);
		promote_state.phase = PROMOTE_PHASE_IN_PROGRESS;
		promote_state.sync_count = 0;
		promote_state.participant_count = 0;
		promote_state.is_master_demoted = false;
		promote_state.comment[0] = 0;
		/*
		 * Timeout, quorum, initiator and round type can
		 * not be set right now, because the first message
		 * may be non-begin and thus does not contain any
		 * round initial info. Such message reordeing is
		 * possible when, for example, one instance
		 * downloads the same round messages from two
		 * different instances. Some of them can be
		 * received earlier, but committed later breaking
		 * the order. So it is not allowed to trust the
		 * order of messages from different sources.
		 */
		promote_state_set_role(PROMOTE_ROLE_UNDEFINED);
		promote_state.round_type = ROUND_TYPE_UNDEFINED;
		promote_state.initiator_uuid = uuid_nil;
	} else if (! promote_is_this_round_msg(msg)) {
		/*
		 * Do not respond error on error, or else an
		 * infinite error messages exchange will be
		 * started.
		 */
		if (msg->type == PROMOTE_MSG_ERROR)
			return;
		diag_set(ClientError, ER_PROMOTE, tt_uuid_str(&msg->round_uuid),
			 "unexpected message");
		promote_send_out_of_bound_error(msg->round_id, &msg->round_uuid,
						msg->step + 1);
		return;
	}
	promote_state.step = MAX(msg->step, promote_state.step);

	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		++promote_state.participant_count;
		promote_state.vtab->begin(msg);
		break;
	case PROMOTE_MSG_STATUS:
		++promote_state.participant_count;
		if (! msg->status.is_master) {
			promote_state.vtab->new_replica(msg);
		} else {
			if (! msg->status.is_promoted)
				promote_state.is_master_demoted = true;
			promote_state.master_uuid = msg->source_uuid;
			promote_state.vtab->new_master(msg);
		}
		break;
	case PROMOTE_MSG_SYNC:
		promote_state.vtab->sync(msg);
		break;
	case PROMOTE_MSG_SUCCESS:
		promote_state.vtab->success(msg);
		break;
	case PROMOTE_MSG_DEMOTE:
		promote_state.is_master_demoted = true;
		promote_state.vtab->demote(msg);
		break;
	case PROMOTE_MSG_PROMOTE:
		promote_state.vtab->promote(msg);
		break;
	case PROMOTE_MSG_ERROR:
		promote_state.vtab->error(msg);
		break;
	default:
		unreachable();
		break;
	}
	promote_state.round_id = MAX(promote_state.round_id, msg->round_id);
	fiber_cond_broadcast(&promote_state.on_change);
}

/**
 * Background worker processing promotion messages, handling
 * timeouts.
 */
static int
promote_worker_f(va_list ap)
{
	(void) ap;
	fiber_set_cancellable(true);
	ev_tstamp *start = &promote_state.round_start;
	ev_tstamp *delay = &promote_state.round_delay;
	evio_timeout_init(loop(), start, delay, TIMEOUT_INFINITY);
	struct promote_msg *msg;
	while (true) {
		int rc = fiber_channel_get_msg_timeout(promote_state.channel,
						       (struct ipc_msg **) &msg,
						       *delay);
		evio_timeout_update(loop(), *start, delay);
		if (rc == 0) {
			promote_msg_process(msg);
			promote_msg_delete(msg);
			if (! promote_is_active()) {
				evio_timeout_init(loop(), start, delay,
						  TIMEOUT_INFINITY);
			}
			continue;
		}
		if (fiber_is_cancelled())
			break;
		if (! promote_is_active()) {
			evio_timeout_init(loop(), start, delay,
					  TIMEOUT_INFINITY);
		} else if (! box_is_configured()) {
			/*
			 * If a recovery is long enough, promotion
			 * round can expire during it. But a
			 * message can not be sent during recovery
			 * so reschedule it.
			 */
			evio_timeout_init(loop(), start, delay,
					  promote_state.timeout);
		} else {
			promote_state.step++;
			promote_send_error();
		}
	}
	fiber_channel_delete(promote_state.channel);
	fiber_cond_destroy(&promote_state.on_change);
	return 0;
}

int
box_ctl_promote_init(void)
{
	memset(&promote_state, 0, sizeof(promote_state));
	fiber_cond_create(&promote_state.on_change);
	promote_state.channel = fiber_channel_new(100);
	promote_state.worker = fiber_new("promote worker", promote_worker_f);
	if (promote_state.worker == NULL)
		panic("Can not start a promotion worker");
	fiber_start(promote_state.worker);
	return 0;
}

void
box_ctl_promote_free(void)
{
	fiber_cancel(promote_state.worker);
}
